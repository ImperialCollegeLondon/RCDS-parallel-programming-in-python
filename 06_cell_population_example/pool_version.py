import numpy as np
import matplotlib.pyplot as plt
import random
import time
import multiprocessing
from process_visualisation import visualise_realisation_runtimes
import pandas as pd

def generate_next_population(reproduction_probability, mean_lifetime, remaining_time):
    '''
    Generate the next population of cells after a time step.
    Assumes 1 cell is present at the start of the time step.
    Parameters:
    reproduction_probability (float): The probability that a cell will reproduce before it dies.
    mean_lifetime (float): The average lifetime of a cell (until death or reproduction).
    remaining_time (float): The remaining time in the current time step.
    Returns:
    int: The number of cells present at the end of the time step.
    '''

    # Generate the lifetime of this cell
    generated_lifetime = random.expovariate(1 / mean_lifetime)

    if generated_lifetime > remaining_time:
        # The cell survives the time step but doesn't reproduce
        return 1
    else:
        # The cell ends its life
        if random.random() < reproduction_probability:
            # The cell reproduces
            # Add the number of cells generated by the two daughter cells
            return generate_next_population(reproduction_probability, mean_lifetime, remaining_time - generated_lifetime) + generate_next_population(reproduction_probability, mean_lifetime, remaining_time - generated_lifetime)
        else:
            # The cell dies
            return 0


def run_realisation(n_initial, reproduction_probability, mean_lifetime, output_times, seed=None):
    '''
    Run a single realisation of the cell population model.
    Parameters:
    n_initial (int): The initial number of cells.
    reproduction_probability (float): The probability that a cell will reproduce before it dies.
    mean_lifetime (float): The average lifetime of a cell (until death or reproduction).
    output_times (ndarray): The times at which to record the population.
    Returns:
    ndarray: The number of cells at each time in output_times.
    '''

    if seed is not None:
        random.seed(seed)

    start_time = time.time()

    # Initialise the output array
    output_populations = np.zeros(len(output_times), dtype=int)
    output_populations[0] = n_initial

    for i_time in range(1, len(output_times)):
        # Advance to the next time step
        delta_t = output_times[i_time] - output_times[i_time - 1]
        for i_cell in range(output_populations[i_time - 1]):
            # For each cell present at the start of the time step, generate and add its contribution to the population at the end of the time step
            output_populations[i_time] += generate_next_population(reproduction_probability, mean_lifetime, delta_t)
        if output_populations[i_time] == 0:
            # If the population has died out, stop the simulation
            break

    runtime = time.time() - start_time
    try:
        process_number = int(multiprocessing.current_process().name.split('-')[-1])
    except ValueError:
        process_number = 0
    realisation_number = seed

    return output_populations, runtime, process_number, realisation_number


def run_single_realisation(n_initial, reproduction_probability, mean_lifetime, output_times, output_filepath, seed=None):
    '''
    Run a single realisation of the cell population model and save the results to a file.
    Parameters:
    n_initial (int): The initial number of cells.
    reproduction_probability (float): The probability that a cell will reproduce before it dies.
    mean_lifetime (float): The average lifetime of a cell (until death or reproduction).
    output_times (ndarray): The times at which to record the population.
    output_filepath (str): The path to save the output plot.
    '''

    # Run the realisation
    populations, run_time, process_number, realisation_number = run_realisation(n_initial, reproduction_probability, mean_lifetime, output_times, seed=seed)

    start_time = time.time()

    # Plot the results
    fig, ax = plt.subplots()
    ax.plot(output_times, populations)
    ax.set_xlabel('Time')
    ax.set_ylabel('Population')
    ax.set_title('Population dynamics')
    if max(populations) > 100:
        ax.set_yscale('log')
    fig.savefig(output_filepath)

    plotting_time = time.time() - start_time

    return run_time, plotting_time


def run_realisation_interface(args):
    return run_realisation(*args)


def run_multiple_realisations(n_initial, reproduction_probability, mean_lifetime, output_times, n_realisations, output_filepath, n_processes=1):
    '''
    Run multiple realisations of the cell population model and plot the results.
    Parameters:
    n_initial (int): The initial number of cells.
    reproduction_probability (float): The probability that a cell will reproduce before it dies.
    mean_lifetime (float): The average lifetime of a cell (until death or reproduction).
    output_times (ndarray): The times at which to record the population.
    n_realisations (int): The number of realisations to run.
    output_filepath (str): The path to save the output plot
    '''

    start_time = time.time()

    arguments = [(n_initial, reproduction_probability, mean_lifetime, output_times, i) for i in range(n_realisations)]

    with multiprocessing.Pool(4) as p:
        output_list = p.map(run_realisation_interface, arguments)

    # Make a 2D array to store the populations of each realisation at each time
    output_populations = np.array([output[0] for output in output_list])

    # Calculate the mean and standard deviation of the populations and survival probability at each time
    population_mean = np.mean(output_populations, axis=0)
    population_standard_deviation = np.std(output_populations, axis=0)
    survival_probability = np.sum(output_populations > 0, axis=0) / n_realisations

    run_time = time.time() - start_time

    # Plot the results
    fig, ax = plt.subplots()
    ax.plot(output_times, population_mean, label='Mean', linestyle = '-')
    ax.plot(output_times, population_standard_deviation, label='Standard deviation', linestyle='--')
    ax.set_xlabel('Time')
    if max(population_mean) > 100:
        ax.set_yscale('log')
    ax2 = ax.twinx()
    ax2.plot(output_times, survival_probability, label='Survival Probability', color='r', linestyle=':')
    ax2.set_ylabel('Survival Probability')
    fig.legend()
    ax.set_title('Population dynamics with survival probability')
    fig.savefig(output_filepath, bbox_inches='tight')

    plotting_time = time.time() - run_time - start_time

    realisation_df = pd.DataFrame(output_list[1:], columns=['population', 'run_time', 'process', 'number'])

    return run_time, plotting_time, realisation_df

if __name__ == '__main__':
    # Some sample calls of the functions
    output_times = np.linspace(0, 100, 1000)

    # On average, the population will grow
    reproduction_probability = 0.55
    mean_lifetime = 1

    # Time and run a single realisation 
    run_time, plotting_time = run_single_realisation(1, reproduction_probability, mean_lifetime, output_times, '06_cell_population_example/single_quick_death.png', seed=0)
    print(f'Single realisation quick death running time: {run_time}s; plotting time: {plotting_time}s')

    # Time and run a single realisation
    run_time, plotting_time = run_single_realisation(1, reproduction_probability, mean_lifetime, output_times, '06_cell_population_example/single_growing_population.png', seed=42)
    print(f'Growing population realisation quick death running time: {run_time}s; plotting time: {plotting_time}s')

    # Time and run multiple realisations
    run_time, plotting_time, realisation_df = run_multiple_realisations(1, reproduction_probability, mean_lifetime, output_times, 200, '06_cell_population_example/multiple_realisations.png', n_processes=4)
    print(f'Multiple realisations running time: {run_time}s; plotting time: {plotting_time}s')

    visualise_realisation_runtimes(realisation_df, '06_cell_population_example/pool_runtimes.png')

