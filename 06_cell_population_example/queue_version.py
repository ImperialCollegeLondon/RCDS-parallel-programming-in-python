import numpy as np
import matplotlib.pyplot as plt
import random
import time
import multiprocessing
import pandas as pd
from process_visualisation import visualise_realisation_runtimes

def generate_next_population(reproduction_probability, mean_lifetime, remaining_time):
    '''
    Generate the next population of cells after a time step.
    Assumes 1 cell is present at the start of the time step.
    Parameters:
    reproduction_probability (float): The probability that a cell will reproduce before it dies.
    mean_lifetime (float): The average lifetime of a cell (until death or reproduction).
    remaining_time (float): The remaining time in the current time step.
    Returns:
    int: The number of cells present at the end of the time step.
    '''

    # Generate the lifetime of this cell
    generated_lifetime = random.expovariate(1 / mean_lifetime)

    if generated_lifetime > remaining_time:
        # The cell survives the time step but doesn't reproduce
        return 1
    else:
        # The cell ends its life
        if random.random() < reproduction_probability:
            # The cell reproduces
            # Add the number of cells generated by the two daughter cells
            return generate_next_population(reproduction_probability, mean_lifetime, remaining_time - generated_lifetime) + generate_next_population(reproduction_probability, mean_lifetime, remaining_time - generated_lifetime)
        else:
            # The cell dies
            return 0


def run_realisation(n_initial, reproduction_probability, mean_lifetime, output_times, seed=None):
    '''
    Run a single realisation of the cell population model.
    Parameters:
    n_initial (int): The initial number of cells.
    reproduction_probability (float): The probability that a cell will reproduce before it dies.
    mean_lifetime (float): The average lifetime of a cell (until death or reproduction).
    output_times (ndarray): The times at which to record the population.
    Returns:
    ndarray: The number of cells at each time in output_times.
    '''

    if seed is not None:
        random.seed(seed)
    start_time = time.time()

    # Initialise the output array
    output_populations = np.zeros(len(output_times), dtype=int)
    output_populations[0] = n_initial

    for i_time in range(1, len(output_times)):
        # Advance to the next time step
        delta_t = output_times[i_time] - output_times[i_time - 1]
        for i_cell in range(output_populations[i_time - 1]):
            # For each cell present at the start of the time step, generate and add its contribution to the population at the end of the time step
            output_populations[i_time] += generate_next_population(reproduction_probability, mean_lifetime, delta_t)
        if output_populations[i_time] == 0:
            # If the population has died out, stop the simulation
            break

    return output_populations


def run_single_realisation(n_initial, reproduction_probability, mean_lifetime, output_times, output_filepath, seed=None):
    '''
    Run a single realisation of the cell population model and save the results to a file.
    Parameters:
    n_initial (int): The initial number of cells.
    reproduction_probability (float): The probability that a cell will reproduce before it dies.
    mean_lifetime (float): The average lifetime of a cell (until death or reproduction).
    output_times (ndarray): The times at which to record the population.
    output_filepath (str): The path to save the output plot.
    '''

    start_time = time.time()

    # Run the realisation
    populations = run_realisation(n_initial, reproduction_probability, mean_lifetime, output_times, seed=seed)

    run_time = time.time() - start_time

    # Plot the results
    fig, ax = plt.subplots()
    ax.plot(output_times, populations)
    ax.set_xlabel('Time')
    ax.set_ylabel('Population')
    ax.set_title('Population dynamics')
    if max(populations) > 100:
        ax.set_yscale('log')
    fig.savefig(output_filepath)

    plotting_time = time.time() - run_time - start_time

    return run_time, plotting_time


def run_n_realisations_queue(n_initial, reproduction_probability, mean_lifetime, output_times, n_realisations, queue):
    '''
    Run n_realisations of the cell population model and store the results in a queue.
    Parameters:
    n_initial (int): The initial number of cells.
    reproduction_probability (float): The probability that a cell will reproduce before it dies.
    mean_lifetime (float): The average lifetime of a cell (until death or reproduction).
    output_times (ndarray): The times at which to record the population.
    n_realisations (int): The number of realisations to run.
    queue (Queue): The queue to store the results.
    '''
    output_populations = np.zeros((n_realisations, len(output_times)))

    runtimes = np.zeros(n_realisations)

    process_number = int(multiprocessing.current_process().name.split('-')[-1])

    for i_realisation in range(n_realisations):
        # Run each realisation and store the results
        start_time = time.time()
        seed = (int(process_number) - 1) * n_realisations + i_realisation
        output_populations[i_realisation, :] = run_realisation(n_initial, reproduction_probability, mean_lifetime, output_times, seed=seed)

        runtimes[i_realisation] = time.time() - start_time
    queue.put((output_populations, runtimes, process_number))
    # A print statement so we know when the process has finished
    print(f'Process {process_number} is finished')


def run_multiple_realisations(n_initial, reproduction_probability, mean_lifetime, output_times, n_realisations, output_filepath, n_process=1):
    '''
    Run multiple realisations of the cell population model and plot the results.
    Parameters:
    n_initial (int): The initial number of cells.
    reproduction_probability (float): The probability that a cell will reproduce before it dies.
    mean_lifetime (float): The average lifetime of a cell (until death or reproduction).
    output_times (ndarray): The times at which to record the population.
    n_realisations (int): The number of realisations to run.
    output_filepath (str): The path to save the output plot
    '''

    # Record the start time for demonstration purposes
    start_time = time.time()

    # Split the realisations into processes to run in parallel
    n_per_process = n_realisations // n_process
    n_realisations = n_process * n_per_process

    queue = multiprocessing.Queue()
    processes = []
    for i_process in range(n_process):
        process = multiprocessing.Process(target=run_n_realisations_queue, args=(n_initial, reproduction_probability, mean_lifetime, output_times, n_per_process, queue))
        process.start()
        processes.append(process)

    # Make a 2D array to store the populations of each realisation at each time
    output_populations = np.zeros((n_realisations, len(output_times)))

    realisation_df = None

    for i_process in range(n_process):
        process = processes[i_process]
        new_populations, runtimes, process_number = queue.get()
        print(f'Received data from {i_process + 1} processes after {time.time() - start_time:.2f} seconds')

        output_populations[i_process * n_per_process:(i_process + 1) * n_per_process, :] = new_populations

        new_df = pd.DataFrame({'number': range(n_per_process * (process_number - 1), n_per_process *(process_number)), 'process': [process_number] * n_per_process, 'run_time': runtimes})

        if realisation_df is None:
            realisation_df = new_df
        else:
            realisation_df = pd.concat([realisation_df, new_df])


    # Calculate the mean and standard deviation of the populations and survival probability at each time
    population_mean = np.mean(output_populations, axis=0)
    population_standard_deviation = np.std(output_populations, axis=0)
    survival_probability = np.sum(output_populations > 0, axis=0) / n_realisations

    running_time = time.time() - start_time

    # Plot the results
    fig, ax = plt.subplots()
    ax.plot(output_times, population_mean, label='Mean', linestyle = '-')
    ax.plot(output_times, population_standard_deviation, label='Standard deviation', linestyle='--')
    ax.set_xlabel('Time')
    if max(population_mean) > 100:
        ax.set_yscale('log')
    ax2 = ax.twinx()
    ax2.plot(output_times, survival_probability, label='Survival Probability', color='r', linestyle=':')
    ax2.set_ylabel('Survival Probability')
    fig.legend()
    ax.set_title('Population dynamics with survival probability')
    fig.savefig(output_filepath, bbox_inches='tight')

    plotting_time = time.time() - start_time - running_time

    return running_time, plotting_time, realisation_df

if __name__ == '__main__':
    # Some sample calls of the functions
    output_times = np.linspace(0, 100, 1000)

    # On average, the population will grow
    reproduction_probability = 0.55
    mean_lifetime = 1

    # Time and run a single realisation 
    run_time, plotting_time = run_single_realisation(1, reproduction_probability, mean_lifetime, output_times, '06_cell_population_example/single_quick_death.png', seed=0)
    print(f'Single realisation quick death running time: {run_time}s; plotting time: {plotting_time}s')

    # Time and run a single realisation
    run_time, plotting_time = run_single_realisation(1, reproduction_probability, mean_lifetime, output_times, '06_cell_population_example/single_growing_population.png', seed=42)
    print(f'Growing population realisation quick death running time: {run_time}s; plotting time: {plotting_time}s')

    # Time and run multiple realisations
    run_time, plotting_time, realisation_df = run_multiple_realisations(1, reproduction_probability, mean_lifetime, output_times, 200, '06_cell_population_example/multiple_realisations.png', n_process=4)
    print(f'Multiple realisations running time: {run_time}s; plotting time: {plotting_time}s')

    visualise_realisation_runtimes(realisation_df, '06_cell_population_example/queue_runtimes.png')







