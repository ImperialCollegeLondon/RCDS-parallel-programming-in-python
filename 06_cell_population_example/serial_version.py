import numpy as np
import matplotlib.pyplot as plt
import random
import time

def generate_next_population(reproduction_probability, mean_lifetime, remaining_time):
    '''
    Generate the next population of cells after a time step.
    Assumes 1 cell is present at the start of the time step.
    Parameters:
    reproduction_probability (float): The probability that a cell will reproduce before it dies.
    mean_lifetime (float): The average lifetime of a cell (until death or reproduction).
    remaining_time (float): The remaining time in the current time step.
    Returns:
    int: The number of cells present at the end of the time step.
    '''

    # Generate the lifetime of this cell
    generated_lifetime = random.expovariate(1 / mean_lifetime)

    if generated_lifetime > remaining_time:
        # The cell survives the time step but doesn't reproduce
        return 1
    else:
        # The cell ends its life
        if random.random() < reproduction_probability:
            # The cell reproduces
            # Add the number of cells generated by the two daughter cells
            return generate_next_population(reproduction_probability, mean_lifetime, remaining_time - generated_lifetime) + generate_next_population(reproduction_probability, mean_lifetime, remaining_time - generated_lifetime)
        else:
            # The cell dies
            return 0


def run_realisation(n_initial, reproduction_probability, mean_lifetime, output_times):
    '''
    Run a single realisation of the cell population model.
    Parameters:
    n_initial (int): The initial number of cells.
    reproduction_probability (float): The probability that a cell will reproduce before it dies.
    mean_lifetime (float): The average lifetime of a cell (until death or reproduction).
    output_times (ndarray): The times at which to record the population.
    Returns:
    ndarray: The number of cells at each time in output_times.
    '''

    # Initialise the output array
    output_populations = np.zeros(len(output_times), dtype=int)
    output_populations[0] = n_initial

    for i_time in range(1, len(output_times)):
        # Advance to the next time step
        delta_t = output_times[i_time] - output_times[i_time - 1]
        for i_cell in range(output_populations[i_time - 1]):
            # For each cell present at the start of the time step, generate and add its contribution to the population at the end of the time step
            output_populations[i_time] += generate_next_population(reproduction_probability, mean_lifetime, delta_t)
        if output_populations[i_time] == 0:
            # If the population has died out, stop the simulation
            break

    return output_populations


def run_single_realisation(n_initial, reproduction_probability, mean_lifetime, output_times, output_filepath):
    '''
    Run a single realisation of the cell population model and save the results to a file.
    Parameters:
    n_initial (int): The initial number of cells.
    reproduction_probability (float): The probability that a cell will reproduce before it dies.
    mean_lifetime (float): The average lifetime of a cell (until death or reproduction).
    output_times (ndarray): The times at which to record the population.
    output_filepath (str): The path to save the output plot.
    '''

    # Run the realisation
    populations = run_realisation(n_initial, reproduction_probability, mean_lifetime, output_times)

    # Plot the results
    fig, ax = plt.subplots()
    ax.plot(output_times, populations)
    ax.set_xlabel('Time')
    ax.set_ylabel('Population')
    ax.set_title('Population dynamics')
    if max(populations) > 100:
        ax.set_yscale('log')
    fig.savefig(output_filepath)


def run_multiple_realisations(n_initial, reproduction_probability, mean_lifetime, output_times, n_realisations, output_filepath):
    '''
    Run multiple realisations of the cell population model and plot the results.
    Parameters:
    n_initial (int): The initial number of cells.
    reproduction_probability (float): The probability that a cell will reproduce before it dies.
    mean_lifetime (float): The average lifetime of a cell (until death or reproduction).
    output_times (ndarray): The times at which to record the population.
    n_realisations (int): The number of realisations to run.
    output_filepath (str): The path to save the output plot
    '''

    # Make a 2D array to store the populations of each realisation at each time
    output_populations = np.zeros((n_realisations, len(output_times)))

    for i_realisation in range(n_realisations):
        # Run each realisation and store the results
        output_populations[i_realisation, :] = run_realisation(n_initial, reproduction_probability, mean_lifetime, output_times)

    # Calculate the mean and standard deviation of the populations and survival probability at each time
    population_mean = np.mean(output_populations, axis=0)
    population_standard_deviation = np.std(output_populations, axis=0)
    survival_probability = np.sum(output_populations > 0, axis=0) / n_realisations

    # Plot the results
    fig, ax = plt.subplots()
    ax.plot(output_times, population_mean, label='Mean', linestyle = '-')
    ax.plot(output_times, population_standard_deviation, label='Standard deviation', linestyle='--')
    ax.set_xlabel('Time')
    if max(population_mean) > 100:
        ax.set_yscale('log')
    ax2 = ax.twinx()
    ax2.plot(output_times, survival_probability, label='Survival Probability', color='r', linestyle=':')
    ax2.set_ylabel('Survival Probability')
    fig.legend()
    ax.set_title('Population dynamics with survival probability')
    fig.savefig(output_filepath, bbox_inches='tight')

if __name__ == '__main__':
    # Some sample calls of the functions
    output_times = np.linspace(0, 100, 1000)

    # On average, the population will grow
    reproduction_probability = 0.55
    mean_lifetime = 1

    # Time and run a single realisation 
    # Choose a seed for reproducibility and to guarantee the population dies out
    random.seed(0)
    start_time = time.time()
    single_realisation_population = run_single_realisation(1, reproduction_probability, mean_lifetime, output_times, '06_cell_population_example/single_quick_death.png')
    print('Single realisation quick death time:', time.time() - start_time)

    # Time and run a single realisation
    # Choose a seed for reproducibility and to guarantee the population grows
    random.seed(42)
    start_time = time.time()
    run_single_realisation(1, reproduction_probability, mean_lifetime, output_times, '06_cell_population_example/single_growing_population.png')
    print('Single realisation growing population:', time.time() - start_time)

    # Time and run multiple realisations
    start_time = time.time()
    run_multiple_realisations(1, reproduction_probability, mean_lifetime, output_times, 100, '06_cell_population_example/multiple_realisations.png')
    print('Multiple realisations time:', time.time() - start_time)







